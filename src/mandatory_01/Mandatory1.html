<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>IS-211 Mandatory 1</title>
      <meta charset="UTF8"/>
      <style type="text/css">
body {
  border: thin solid black;
  margin: auto;
  padding: 25px;
  padding-top: 0;
  font-size: 12pt;
  width: 75ex;  
}

h1, h2, h3 {
  padding-top: 1em;
  padding-bottom: 0;
  margin: 0;
}

table.plain {
  border-width : thin;
  border-style : solid;
  border-collapse : collapse;
  border-color : black;
}
table.plain td,
table.plain th {
  border-width : thin;
  border-style : solid;
  vertical-align : top;
  padding : 3px;
}            
        </style>
    </head>
    <body>
      <h1>IS-211 Mandatory Exercise 1</h1>  
      <h3>Purpose</h3>
      <p>Learn how to use an empirical approach to analyze an algorithm.</p>
      <h3>Theory (sort of...)</h3>
      <p>Find the time complexity of the InsertSort and BubbleSort algorithms.</p>
      <p>   When we analyze an algorithm
        empirically, we do not use mathematics to find the time complexity. We just count how many
        times the algorithm uses some basic operations: Typically comparisons and moving or swapping
        data items. We must do this for several problem sizes. For sort algorithms the number
      of data elements to sort (n) is the best measure of problem size. To find the function of n
      to put in the Big-O notation, we can divide the counter values by the function. If we get
      similar values for all sizes of n, we have found the right function. See the example in the
      table below (the numbers are fake, to illustrate). This algorithm is not O(n), because the
      the result  of the division diminishes, but the division with log(n) gives a constant result,
      so the algorithm is probably O(log(n))</p>
      <p>A slightly mathematical explanation of why this works: If the time complexity of
        an algorith is O(f(n)), this means that the time it uses is proportional to f(n), or in
        mathematical notation: time = c * f(n). Divide by f(n) and we get c = time/f(n). The number c
        is supposed to be constant, so if we run the algorithm on several problem sizes, we
        can try different functions until we find one where the division always gives 
        the same result for all n.</p>
      <table>
      <tr>
        <th>n</th>
        <td>10</td>
        <td>100</td>
        <td>1000</td>
        <td>10000</td>
      </tr>
      <tr>
        <th>count</th>
        <td>3</td>
        <td>6</td>
        <td>9</td>
        <td>12</td>
      </tr>
      <tr>
        <th>count/log10(n)</th>
        <td>3</td>
        <td>3</td>
        <td>3</td>
        <td>3</td>
      </tr>
      <tr>
        <th>count/n</th>
        <td>0.3</td>
        <td>.06</td>
        <td>0.009</td>
        <td>0.0012</td>
      </tr>
    </table>
        
    <h3>Task</h3>
      <p>You will find an
        implementation of the algorithms in the classes InsertSortAnalysis, and BubbleSortAnalysis.
        Both are subclasses of EmpiricalAnalysis, which is a framework for empirical analysis of
        (sorting) algorithms. The framework will run the algorithms for increasing values of
        n (10, 100, 1000,...), and count the number of basic operations for each n.
        The limits for n is set in main, to the maximum that I have the patience to wait for.
        When the last run is finished it will display a summary of the result, with the counters
        divided by common orders of complexity</p>
      
      <p>To complete the task, you have to add the counting of basic operations. There are 
      some methods in EmpiricalAnalysis that you can use (equal(), greaterThan(), lessThan(),
      swap(), and assign()). They increment predefined counters. Alternatively you can define
      your own counters and call incrementCounter() in the right places. That is every time
      the algorithm compares or moves data items.</p>

      <p>Hand in the code, and a short note (1 page), where you answer the following questions:</p>
      <ol>
        <li>What is the time complexity of InsertSort and BubbleSort in Big-O notation?</li>
        <li>One of the algorithms is noticeably faster than the other. Which is the faster one?</li>
        <li>What causes the difference in performance?</li>
      </ol>
            
      <h2>Deadline</h2>
      Thursday 2nd February, before the lecture
      <p></p>
    </body>
</html>